/** A List of promises, that are resolved one after the other, despite bing asyncronious */
export default class PromiseQueue {

    /**
     * Add a new promise to the element
     *
     * @param {any} context - the object, that represents 'this'
     * @param {(...args) => Promise<any>} fnc - the promise generating function, that will be called, when its time in the queue has come
     * @param {any[]} args - additional arguments, that will be passed to 'fnc', when it is called
     *
     * @returns {Promise.<any>} a promise, that only resolves/rejects, once the Promise generated by 'fnc' resolves/rejects 
     */
    add(context, fnc, ...args) {
        return new Promise((resolve, reject) => {
            this.queue.push({c: context, f: fnc, a: args, r: resolve, e: reject});
            this.run();
        })
    }

    constructor() {
        /** @private */ this.job = undefined;
        /** @private */ this.queue = []
    }

    /** @private */
    run() {
        if(this.job) return;

        this.job = this.queue.shift();
        if(!this.job) return; 

        this.job.f.apply(this.job.c, this.job.a)
            .then( this.job.r )
            .catch( this.job.e )
            .finally( () => {
                this.job = undefined;
                setTimeout( () => this.run(), 0 )
            } )
    }
};
